//this file is autogenerated using stringify.bat (premake --stringify) in the build folder of this project
static const char* rayCastKernelCL= \
"#define SHAPE_CONVEX_HULL 3\n"
"#define SHAPE_PLANE 4\n"
"#define SHAPE_CONCAVE_TRIMESH 5\n"
"#define SHAPE_COMPOUND_OF_CONVEX_HULLS 6\n"
"#define SHAPE_SPHERE 7\n"
"typedef struct\n"
"{\n"
"	float4 m_from;\n"
"	float4 m_to;\n"
"} b3RayInfo;\n"
"typedef struct\n"
"{\n"
"	float m_hitFraction;\n"
"	int	m_hitResult0;\n"
"	int	m_hitResult1;\n"
"	int	m_hitResult2;\n"
"	float4	m_hitPoint;\n"
"	float4	m_hitNormal;\n"
"} b3RayHit;\n"
"typedef struct\n"
"{\n"
"	float4 m_pos;\n"
"	float4 m_quat;\n"
"	float4 m_linVel;\n"
"	float4 m_angVel;\n"
"	unsigned int m_collidableIdx;\n"
"	float m_invMass;\n"
"	float m_restituitionCoeff;\n"
"	float m_frictionCoeff;\n"
"} Body;\n"
"typedef struct Collidable\n"
"{\n"
"	union {\n"
"		int m_numChildShapes;\n"
"		int m_bvhIndex;\n"
"	};\n"
"	float m_radius;\n"
"	int m_shapeType;\n"
"	int m_shapeIndex;\n"
"} Collidable;\n"
"typedef struct  \n"
"{\n"
"	float4		m_localCenter;\n"
"	float4		m_extents;\n"
"	float4		mC;\n"
"	float4		mE;\n"
"	float			m_radius;\n"
"	int	m_faceOffset;\n"
"	int m_numFaces;\n"
"	int	m_numVertices;\n"
"	int m_vertexOffset;\n"
"	int	m_uniqueEdgesOffset;\n"
"	int	m_numUniqueEdges;\n"
"	int m_unused;\n"
"} ConvexPolyhedronCL;\n"
"typedef struct\n"
"{\n"
"	float4 m_plane;\n"
"	int m_indexOffset;\n"
"	int m_numIndices;\n"
"} b3GpuFace;\n"
"///////////////////////////////////////\n"
"//	Quaternion\n"
"///////////////////////////////////////\n"
"typedef float4 Quaternion;\n"
"__inline\n"
"	Quaternion qtMul(Quaternion a, Quaternion b);\n"
"__inline\n"
"	Quaternion qtNormalize(Quaternion in);\n"
"__inline\n"
"	Quaternion qtInvert(Quaternion q);\n"
"__inline\n"
"	float dot3F4(float4 a, float4 b)\n"
"{\n"
"	float4 a1 = (float4)(a.xyz,0.f);\n"
"	float4 b1 = (float4)(b.xyz,0.f);\n"
"	return dot(a1, b1);\n"
"}\n"
"__inline\n"
"	Quaternion qtMul(Quaternion a, Quaternion b)\n"
"{\n"
"	Quaternion ans;\n"
"	ans = cross( a, b );\n"
"	ans += a.w*b+b.w*a;\n"
"	//	ans.w = a.w*b.w - (a.x*b.x+a.y*b.y+a.z*b.z);\n"
"	ans.w = a.w*b.w - dot3F4(a, b);\n"
"	return ans;\n"
"}\n"
"__inline\n"
"	Quaternion qtNormalize(Quaternion in)\n"
"{\n"
"	return fast_normalize(in);\n"
"	//	in /= length( in );\n"
"	//	return in;\n"
"}\n"
"__inline\n"
"	float4 qtRotate(Quaternion q, float4 vec)\n"
"{\n"
"	Quaternion qInv = qtInvert( q );\n"
"	float4 vcpy = vec;\n"
"	vcpy.w = 0.f;\n"
"	float4 out = qtMul(q,vcpy);\n"
"	out = qtMul(out,qInv);\n"
"	return out;\n"
"}\n"
"__inline\n"
"	Quaternion qtInvert(Quaternion q)\n"
"{\n"
"	return (Quaternion)(-q.xyz, q.w);\n"
"}\n"
"__inline\n"
"	float4 qtInvRotate(const Quaternion q, float4 vec)\n"
"{\n"
"	return qtRotate( qtInvert( q ), vec );\n"
"}\n"
"void	trInverse(float4 translationIn, Quaternion orientationIn,\n"
"	float4* translationOut, Quaternion* orientationOut)\n"
"{\n"
"	*orientationOut = qtInvert(orientationIn);\n"
"	*translationOut = qtRotate(*orientationOut, -translationIn);\n"
"}\n"
"bool rayConvex(float4 rayFromLocal, float4 rayToLocal, int numFaces, int faceOffset,\n"
"	__global const b3GpuFace* faces, float* hitFraction, float4* hitNormal)\n"
"{\n"
"	rayFromLocal.w = 0.f;\n"
"	rayToLocal.w = 0.f;\n"
"	bool result = true;\n"
"	float exitFraction = hitFraction[0];\n"
"	float enterFraction = -0.3f;\n"
"	float4 curHitNormal = (float4)(0,0,0,0);\n"
"	for (int i=0;i<numFaces && result;i++)\n"
"	{\n"
"		b3GpuFace face = faces[faceOffset+i];\n"
"		float fromPlaneDist = dot(rayFromLocal,face.m_plane)+face.m_plane.w;\n"
"		float toPlaneDist = dot(rayToLocal,face.m_plane)+face.m_plane.w;\n"
"		if (fromPlaneDist<0.f)\n"
"		{\n"
"			if (toPlaneDist >= 0.f)\n"
"			{\n"
"				float fraction = fromPlaneDist / (fromPlaneDist-toPlaneDist);\n"
"				if (exitFraction>fraction)\n"
"				{\n"
"					exitFraction = fraction;\n"
"				}\n"
"			} 			\n"
"		} else\n"
"		{\n"
"			if (toPlaneDist<0.f)\n"
"			{\n"
"				float fraction = fromPlaneDist / (fromPlaneDist-toPlaneDist);\n"
"				if (enterFraction <= fraction)\n"
"				{\n"
"					enterFraction = fraction;\n"
"					curHitNormal = face.m_plane;\n"
"					curHitNormal.w = 0.f;\n"
"				}\n"
"			} else\n"
"			{\n"
"				result = false;\n"
"			}\n"
"		}\n"
"		if (exitFraction <= enterFraction)\n"
"			result = false;\n"
"	}\n"
"	if (enterFraction < 0.f)\n"
"	{\n"
"		result = false;\n"
"	}\n"
"	if (result)\n"
"	{	\n"
"		hitFraction[0] = enterFraction;\n"
"		hitNormal[0] = curHitNormal;\n"
"	}\n"
"	return result;\n"
"}\n"
"bool sphere_intersect(float4 spherePos,  float radius, float4 rayFrom, float4 rayTo, float* hitFraction)\n"
"{\n"
"	float4 rs = rayFrom - spherePos;\n"
"	rs.w = 0.f;\n"
"	float4 rayDir = rayTo-rayFrom;\n"
"	rayDir.w = 0.f;\n"
"	float A = dot(rayDir,rayDir);\n"
"	float B = dot(rs, rayDir);\n"
"	float C = dot(rs, rs) - (radius * radius);\n"
"	float D = B * B - A*C;\n"
"	if (D > 0.0f)\n"
"	{\n"
"		float t = (-B - sqrt(D))/A;\n"
"		if ( (t >= 0.0f) && (t < (*hitFraction)) )\n"
"		{\n"
"			*hitFraction = t;\n"
"			return true;\n"
"		}\n"
"	}\n"
"	return false;\n"
"}\n"
"float4 normalize3(float4 v)\n"
"{\n"
"	v.w = 0.f;\n"
"	return fast_normalize(v);	//vector4 normalize\n"
"}\n"
"float4 setInterpolate3(float4 from, float4 to, float t)\n"
"{\n"
"	float s = 1.0f - t;\n"
"	float4 result;\n"
"	result = s * from + t * to;\n"
"	result.w = 0.f;	\n"
"	return result;	\n"
"}\n"
"int rayIntersectsRigidBody(__global Body* bodies,\n"
"						__global Collidable* collidables,\n"
"						__global const b3GpuFace* faces,\n"
"						__global const ConvexPolyhedronCL* convexShapes,\n"
"						float4 rayFrom, float4 rayTo, int rigidBodyIndex, \n"
"						float4* out_normal, float* out_hitFraction)\n"
"{\n"
"	Body body = bodies[rigidBodyIndex];\n"
"	Collidable rigidCollidable = collidables[body.m_collidableIdx];\n"
"	\n"
"	float hitFraction = 1.f;\n"
"	float4 hitNormal;\n"
"	int hitBodyIndex = -1;\n"
"	if (rigidCollidable.m_shapeType == SHAPE_CONVEX_HULL)\n"
"	{\n"
"		float4 invOrn = qtInvert(body.m_quat);\n"
"		float4 invPos = qtRotate(invOrn, -body.m_pos);\n"
"		float4 rayFromLocal = qtRotate( invOrn, rayFrom ) + invPos;\n"
"		float4 rayToLocal = qtRotate( invOrn, rayTo) + invPos;\n"
"		rayFromLocal.w = 0.f;\n"
"		rayToLocal.w = 0.f;\n"
"		\n"
"		int numFaces = convexShapes[rigidCollidable.m_shapeIndex].m_numFaces;\n"
"		int faceOffset = convexShapes[rigidCollidable.m_shapeIndex].m_faceOffset;\n"
"		\n"
"		if (numFaces && rayConvex(rayFromLocal, rayToLocal, numFaces, faceOffset, faces, &hitFraction, &hitNormal))\n"
"		{\n"
"			hitBodyIndex = rigidBodyIndex;\n"
"		}\n"
"	}\n"
"	\n"
"	if (rigidCollidable.m_shapeType == SHAPE_SPHERE)\n"
"	{\n"
"		if ( sphere_intersect(body.m_pos, rigidCollidable.m_radius, rayFrom, rayTo, &hitFraction) )\n"
"		{\n"
"			hitBodyIndex = rigidBodyIndex;\n"
"			float4 hitPoint = setInterpolate3(rayFrom, rayTo, hitFraction);\n"
"			hitNormal = (float4) (hitPoint - bodies[rigidBodyIndex].m_pos);\n"
"		}\n"
"	}\n"
"	\n"
"	if (hitBodyIndex >= 0)\n"
"	{\n"
"		*out_normal = normalize3(hitNormal);\n"
"		*out_hitFraction = hitFraction;\n"
"		return 1;\n"
"	}\n"
"	\n"
"	return 0;\n"
"}\n"
"__kernel void rayCastKernel(\n"
"	int numRays,\n"
"	const __global b3RayInfo* rays,\n"
"	__global b3RayHit* hitResults,\n"
"	const int numBodies,\n"
"	__global Body* bodies,\n"
"	__global Collidable* collidables,\n"
"	__global const b3GpuFace* faces,\n"
"	__global const ConvexPolyhedronCL* convexShapes	)\n"
"{\n"
"	int i = get_global_id(0);\n"
"	if (i >= numRays) return;\n"
"	hitResults[i].m_hitFraction = 1.f;\n"
"	float4 rayFrom = rays[i].m_from;\n"
"	float4 rayTo = rays[i].m_to;\n"
"	\n"
"	float nearestHitFraction = 1.f;\n"
"	float4 nearestNormal;\n"
"	int hitBodyIndex = -1;\n"
"	\n"
"	for (int rigidIndex = 0; rigidIndex < numBodies; rigidIndex++)\n"
"	{\n"
"		if (hitResults[i].m_hitResult2 == rigidIndex) continue;\n"
"		\n"
"		float hitFraction = 1.f;\n"
"		float4 hitNormal;\n"
"		int hasHit = rayIntersectsRigidBody(bodies, collidables, faces, convexShapes, rayFrom, rayTo, rigidIndex, &hitNormal, &hitFraction);\n"
"		if(hasHit && hitFraction < nearestHitFraction)\n"
"		{\n"
"			nearestHitFraction = hitFraction;\n"
"			nearestNormal = hitNormal;\n"
"			hitBodyIndex = rigidIndex;\n"
"		}\n"
"	}\n"
"	\n"
"	if (hitBodyIndex>=0)\n"
"	{\n"
"		float4 hitPoint = setInterpolate3(rayFrom, rayTo, nearestHitFraction);\n"
"		hitResults[i].m_hitFraction = nearestHitFraction;\n"
"		hitResults[i].m_hitPoint = hitPoint;\n"
"		hitResults[i].m_hitNormal = normalize(nearestNormal);\n"
"		hitResults[i].m_hitResult0 = hitBodyIndex;\n"
"	}\n"
"}\n"
"__kernel void findRayRigidPairIndexRanges(__global int2* rayRigidPairs,\n"
"											__global int* out_firstRayRigidPairIndexPerRay,\n"
"											__global int* out_numRayRigidPairsPerRay,\n"
"											int numRayRigidPairs)\n"
"{\n"
"	int rayRigidPairIndex = get_global_id(0);\n"
"	if (rayRigidPairIndex >= numRayRigidPairs) return;\n"
"	\n"
"	int rayIndex = rayRigidPairs[rayRigidPairIndex].x;\n"
"	\n"
"	atomic_min(&out_firstRayRigidPairIndexPerRay[rayIndex], rayRigidPairIndex);\n"
"	atomic_inc(&out_numRayRigidPairsPerRay[rayIndex]);\n"
"}\n"
"__kernel void rayCastPairsKernel(const __global b3RayInfo* rays,\n"
"								__global b3RayHit* hitResultsPerRay,\n"
"								\n"
"								__global Body* bodies,\n"
"								__global Collidable* collidables,\n"
"								__global const b3GpuFace* faces,\n"
"								__global const ConvexPolyhedronCL* convexShapes,\n"
"								\n"
"								__global int2* rayRigidPairs,\n"
"								__global float4* out_normalAndHitFractionPerPair,\n"
"								int numRayRigidPairs)\n"
"{\n"
"	int rayRigidPairIndex = get_global_id(0);\n"
"	if (rayRigidPairIndex >= numRayRigidPairs) return;\n"
"	int rayIndex = rayRigidPairs[rayRigidPairIndex].x;\n"
"	int rigidIndex = rayRigidPairs[rayRigidPairIndex].y;\n"
"	\n"
"	float4 normalAndHitFraction;	//normal in x,y,z and hitFraction in w\n"
"	normalAndHitFraction.w = 1.f;\n"
"	\n"
"	//m_hitResult2 == index of rigid body that is ignored by the ray\n"
"	if (hitResultsPerRay[rayIndex].m_hitResult2 != rigidIndex) \n"
"	{\n"
"		float4 rayFrom = rays[rayIndex].m_from;\n"
"		float4 rayTo = rays[rayIndex].m_to;\n"
"		\n"
"		float hitFraction = 1.f;\n"
"		float4 hitNormal;\n"
"		int hasHit = rayIntersectsRigidBody(bodies, collidables, faces, convexShapes, rayFrom, rayTo, rigidIndex, &hitNormal, &hitFraction);\n"
"		if(hasHit)\n"
"		{\n"
"			normalAndHitFraction = normalize3(hitNormal);\n"
"			normalAndHitFraction.w = hitFraction;\n"
"		}\n"
"	}\n"
"	out_normalAndHitFractionPerPair[rayRigidPairIndex] = normalAndHitFraction;\n"
"}\n"
"__kernel void findFirstHitPerRay(const __global b3RayInfo* rays, \n"
"								__global int2* rayRigidPairs,\n"
"								__global int* firstRayRigidPairIndexPerRay,\n"
"								__global int* numRayRigidPairsPerRay,\n"
"								__global float4* normalAndHitFractionPerPair,\n"
"								__global b3RayHit* out_hitResultsPerRay,\n"
"								int numRays)\n"
"{\n"
"	int rayIndex = get_global_id(0);\n"
"	if(rayIndex >= numRays) return;\n"
"	\n"
"	float nearestHitFraction = 1.f;\n"
"	int nearestRayRigidPairIndex = -1;\n"
"	\n"
"	for(int pair = 0; pair < numRayRigidPairsPerRay[rayIndex]; ++pair)\n"
"	{\n"
"		int rayRigidPairIndex = pair + firstRayRigidPairIndexPerRay[rayIndex];\n"
"		\n"
"		float4 normalAndHitFraction = normalAndHitFractionPerPair[rayRigidPairIndex];\n"
"		float hitFraction = normalAndHitFraction.w;\n"
"		\n"
"		if(hitFraction < nearestHitFraction)\n"
"		{\n"
"			nearestHitFraction = hitFraction;\n"
"			nearestRayRigidPairIndex = rayRigidPairIndex;\n"
"		}\n"
"	}\n"
"	\n"
"	b3RayHit result;\n"
"	result.m_hitFraction = 1.f;\n"
"	result.m_hitResult0 = -1;\n"
"	result.m_hitResult1 = out_hitResultsPerRay[rayIndex].m_hitResult1;\n"
"	result.m_hitResult2 = out_hitResultsPerRay[rayIndex].m_hitResult2;\n"
"	\n"
"	if(nearestRayRigidPairIndex != -1)\n"
"	{\n"
"		float4 normalAndHitFraction = normalAndHitFractionPerPair[nearestRayRigidPairIndex];\n"
"		\n"
"		float hitFraction = normalAndHitFraction.w;\n"
"		float4 hitNormal = normalAndHitFraction;\n"
"		hitNormal.w = 0.f;\n"
"		\n"
"		int rigidIndex = rayRigidPairs[nearestRayRigidPairIndex].y;\n"
"		\n"
"		result.m_hitFraction = hitFraction;\n"
"		result.m_hitResult0 = rigidIndex;\n"
"		result.m_hitPoint = setInterpolate3(rays[rayIndex].m_from, rays[rayIndex].m_to, hitFraction);\n"
"		result.m_hitNormal = hitNormal;\n"
"	}\n"
"	\n"
"	out_hitResultsPerRay[rayIndex] = result;\n"
"}\n"
"typedef float b3Scalar;\n"
"typedef float4 b3Vector3;\n"
"#define b3Max max\n"
"#define b3Min min\n"
"#define b3Sqrt sqrt\n"
"b3Vector3 b3Vector3_normalize(b3Vector3 v)\n"
"{\n"
"	b3Vector3 normal = (b3Vector3){v.x, v.y, v.z, 0.f};\n"
"	return normalize(normal);	//OpenCL normalize == vector4 normalize\n"
"}\n"
"b3Scalar b3Vector3_length2(b3Vector3 v) { return v.x*v.x + v.y*v.y + v.z*v.z; }\n"
"b3Scalar b3Vector3_dot(b3Vector3 a, b3Vector3 b) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n"
"#define B3_PLVBH_TRAVERSE_MAX_STACK_SIZE 128\n"
"int isLeafNode(int index) { return (index >> 31 == 0); }\n"
"int getIndexWithInternalNodeMarkerRemoved(int index) { return index & (~0x80000000); }\n"
"int getIndexWithInternalNodeMarkerSet(int isLeaf, int index) { return (isLeaf) ? index : (index | 0x80000000); }\n"
"typedef struct\n"
"{\n"
"	unsigned int m_key;\n"
"	unsigned int m_value;\n"
"} SortDataCL;\n"
"typedef struct \n"
"{\n"
"	union\n"
"	{\n"
"		float4	m_min;\n"
"		float   m_minElems[4];\n"
"		int			m_minIndices[4];\n"
"	};\n"
"	union\n"
"	{\n"
"		float4	m_max;\n"
"		float   m_maxElems[4];\n"
"		int			m_maxIndices[4];\n"
"	};\n"
"} b3AabbCL;\n"
"b3Scalar rayIntersectsAabb(b3Vector3 rayOrigin, b3Scalar rayLength, b3Vector3 rayNormalizedDirection, b3AabbCL aabb)\n"
"{\n"
"	//AABB is considered as 3 pairs of 2 planes( {x_min, x_max}, {y_min, y_max}, {z_min, z_max} ).\n"
"	//t_min is the point of intersection with the closer plane, t_max is the point of intersection with the farther plane.\n"
"	//\n"
"	//if (rayNormalizedDirection.x < 0.0f), then max.x will be the near plane \n"
"	//and min.x will be the far plane; otherwise, it is reversed.\n"
"	//\n"
"	//In order for there to be a collision, the t_min and t_max of each pair must overlap.\n"
"	//This can be tested for by selecting the highest t_min and lowest t_max and comparing them.\n"
"	\n"
"	int4 isNegative = isless( rayNormalizedDirection, (b3Vector3){0.0f, 0.0f, 0.0f, 0.0f} );	//isless(x,y) returns (x < y)\n"
"	\n"
"	//When using vector types, the select() function checks the most signficant bit, \n"
"	//but isless() sets the least significant bit.\n"
"	isNegative <<= 31;\n"
"	//select(b, a, condition) == condition ? a : b\n"
"	//When using select() with vector types, (condition[i]) is true if its most significant bit is 1\n"
"	b3Vector3 t_min = ( select(aabb.m_min, aabb.m_max, isNegative) - rayOrigin ) / rayNormalizedDirection;\n"
"	b3Vector3 t_max = ( select(aabb.m_max, aabb.m_min, isNegative) - rayOrigin ) / rayNormalizedDirection;\n"
"	\n"
"	b3Scalar t_min_final = 0.0f;\n"
"	b3Scalar t_max_final = rayLength;\n"
"	\n"
"	//Must use fmin()/fmax(); if one of the parameters is NaN, then the parameter that is not NaN is returned. \n"
"	//Behavior of min()/max() with NaNs is undefined. (See OpenCL Specification 1.2 [6.12.2] and [6.12.4])\n"
"	//Since the innermost fmin()/fmax() is always not NaN, this should never return NaN.\n"
"	t_min_final = fmax( t_min.z, fmax(t_min.y, fmax(t_min.x, t_min_final)) );\n"
"	t_max_final = fmin( t_max.z, fmin(t_max.y, fmin(t_max.x, t_max_final)) );\n"
"	\n"
"	return (t_min_final <= t_max_final) ? (t_min_final / rayLength) : 1.f;\n"
"}\n"
"__kernel void plbvhRayTraverseFirstHit(__global b3AabbCL* rigidAabbs,	//Contains only small AABBs\n"
"										__global int* rootNodeIndex, \n"
"										__global int2* internalNodeChildIndices, \n"
"										__global b3AabbCL* internalNodeAabbs,\n"
"										__global SortDataCL* mortonCodesAndAabbIndices,\n"
"										\n"
"										__global Body* bodies,\n"
"										__global Collidable* collidables,\n"
"										__global const b3GpuFace* faces,\n"
"										__global const ConvexPolyhedronCL* convexShapes,\n"
"										\n"
"										__global b3RayInfo* rays,\n"
"										__global b3RayHit* out_hitResults,\n"
"										int numRigids, int numRays)\n"
"{\n"
"	int rayIndex = get_global_id(0);\n"
"	if(rayIndex >= numRays) return;\n"
"	\n"
"	//\n"
"	b3Vector3 rayFrom = rays[rayIndex].m_from;\n"
"	b3Vector3 rayTo = rays[rayIndex].m_to;\n"
"	b3Vector3 rayNormalizedDirection = b3Vector3_normalize(rayTo - rayFrom);\n"
"	b3Scalar rayLength = b3Sqrt( b3Vector3_length2(rayTo - rayFrom) );\n"
"	\n"
"	//\n"
"	int stack[B3_PLVBH_TRAVERSE_MAX_STACK_SIZE];\n"
"	\n"
"	int stackSize = 1;\n"
"	stack[0] = *rootNodeIndex;\n"
"	\n"
"	b3Scalar nearestHitFraction = 1.f;		//Actual ray-rigid hit fraction, not ray-AABB fraction\n"
"	b3Vector3 nearestNormal;\n"
"	int nearestRigidBodyIndex = -1;\n"
"	\n"
"	while(stackSize)\n"
"	{\n"
"		int internalOrLeafNodeIndex = stack[ stackSize - 1 ];\n"
"		--stackSize;\n"
"		\n"
"		int isLeaf = isLeafNode(internalOrLeafNodeIndex);	//Internal node if false\n"
"		int bvhNodeIndex = getIndexWithInternalNodeMarkerRemoved(internalOrLeafNodeIndex);\n"
"		\n"
"		//bvhRigidIndex is not used if internal node\n"
"		int bvhRigidIndex = (isLeaf) ? mortonCodesAndAabbIndices[bvhNodeIndex].m_value : -1;\n"
"	\n"
"		b3AabbCL bvhNodeAabb = (isLeaf) ? rigidAabbs[bvhRigidIndex] : internalNodeAabbs[bvhNodeIndex];\n"
"		\n"
"		b3Scalar aabbHitFraction = rayIntersectsAabb(rayFrom, rayLength, rayNormalizedDirection, bvhNodeAabb);\n"
"		if(aabbHitFraction != 1.f && aabbHitFraction <= nearestHitFraction)\n"
"		{\n"
"			if(isLeaf)\n"
"			{\n"
"				//bvhRigidIndex is the index of the small AABB in the BVH; not the actual rigid index\n"
"				int rigidIndex = bvhNodeAabb.m_minIndices[3];\n"
"				\n"
"				float hitFraction = 1.f;\n"
"				float4 hitNormal;\n"
"				\n"
"				int hasHit = rayIntersectsRigidBody(bodies, collidables, faces, convexShapes, rayFrom, rayTo, rigidIndex, &hitNormal, &hitFraction);\n"
"				if(hasHit && hitFraction < nearestHitFraction)\n"
"				{\n"
"					nearestHitFraction = hitFraction;\n"
"					nearestNormal = hitNormal;\n"
"					nearestRigidBodyIndex = rigidIndex;\n"
"				}\n"
"			}\n"
"			\n"
"			if(!isLeaf)	//Internal node\n"
"			{\n"
"				if(stackSize + 2 > B3_PLVBH_TRAVERSE_MAX_STACK_SIZE)\n"
"				{\n"
"					//Error\n"
"				}\n"
"				else\n"
"				{\n"
"					stack[ stackSize++ ] = internalNodeChildIndices[bvhNodeIndex].x;\n"
"					stack[ stackSize++ ] = internalNodeChildIndices[bvhNodeIndex].y;\n"
"				}\n"
"			}\n"
"		}\n"
"	}\n"
"	\n"
"	b3RayHit result;\n"
"	\n"
"	result.m_hitResult1 = out_hitResults[rayIndex].m_hitResult1;\n"
"	result.m_hitResult2 = out_hitResults[rayIndex].m_hitResult2;\n"
"	\n"
"	result.m_hitFraction = nearestHitFraction;\n"
"	result.m_hitResult0 = nearestRigidBodyIndex;\n"
"	result.m_hitPoint = setInterpolate3(rayFrom, rayTo, nearestHitFraction);\n"
"	result.m_hitNormal = nearestNormal;\n"
"	\n"
"	out_hitResults[rayIndex] = result;\n"
"}\n"
"__kernel void plbvhLargeAabbRayTestFirstHit(__global b3AabbCL* largeRigidAabbs, \n"
"										__global Body* bodies,\n"
"										__global Collidable* collidables,\n"
"										__global const b3GpuFace* faces,\n"
"										__global const ConvexPolyhedronCL* convexShapes,\n"
"										__global b3RayInfo* rays,\n"
"										__global b3RayHit* hitResults,\n"
"										\n"
"										int numLargeAabbRigids, int numRays)\n"
"{\n"
"	int rayIndex = get_global_id(0);\n"
"	if(rayIndex >= numRays) return;\n"
"	\n"
"	b3Vector3 rayFrom = rays[rayIndex].m_from;\n"
"	b3Vector3 rayTo = rays[rayIndex].m_to;\n"
"	b3Vector3 rayNormalizedDirection = b3Vector3_normalize(rayTo - rayFrom);\n"
"	b3Scalar rayLength = b3Sqrt( b3Vector3_length2(rayTo - rayFrom) );\n"
"	\n"
"	\n"
"	b3RayHit result = hitResults[rayIndex];\n"
"	\n"
"	for(int i = 0; i < numLargeAabbRigids; ++i)\n"
"	{\n"
"		b3AabbCL rigidAabb = largeRigidAabbs[i];\n"
"		int rigidIndex = rigidAabb.m_minIndices[3];\n"
"		\n"
"		b3Scalar aabbHitFraction = rayIntersectsAabb(rayFrom, rayLength, rayNormalizedDirection, rigidAabb);\n"
"		if(aabbHitFraction != 1.f && aabbHitFraction <= result.m_hitFraction)\n"
"		{\n"
"			float hitFraction = 1.f;\n"
"			float4 hitNormal;\n"
"			int hasHit = rayIntersectsRigidBody(bodies, collidables, faces, convexShapes, rayFrom, rayTo, rigidIndex, &hitNormal, &hitFraction);\n"
"			if(hasHit && hitFraction < result.m_hitFraction)\n"
"			{\n"
"				result.m_hitFraction = hitFraction;\n"
"				result.m_hitResult0 = rigidIndex;\n"
"				result.m_hitPoint = setInterpolate3(rayFrom, rayTo, hitFraction);\n"
"				result.m_hitNormal = hitNormal;\n"
"			}\n"
"		}\n"
"	}\n"
"	\n"
"	hitResults[rayIndex] = result;\n"
"}\n"
;
